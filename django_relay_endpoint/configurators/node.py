
import graphene
from django.db import models
from django.forms import Field
from graphene_django import DjangoObjectType
from typing import Any, List, Dict, Literal, Union, TypedDict, Callable
from django.apps import apps

from .object_type_configurator import configure_node_object_type
from .queries_configurator import configure_queries
from .mutation_configurators.create_mutation_configurator import configure_create_mutation
from .mutation_configurators.update_mutation_configurator import configure_update_mutation
from .mutation_configurators.delete_mutation_configurator import configure_delete_mutation
from .mutation_configurators.abstract_class_configurator import configure_abstract_mutation
from .mutation_configurators.input_object_type_configurator import configure_input_object_type
from .object_types import DjangoClientIDMutation
from django_filters import FilterSet
from .permissions import assert_permissions_are_valid, assert_permission_classes_are_valid


class MutationConfig(TypedDict):
    graphene_field_kwargs: Dict[str, Any]
    validators: List[Callable]
    graphene_input_field: str
    form_field: Field
    scalar_type: graphene.Scalar


class MetaKwargs(TypedDict):
    """Meta Kwargs dict 

    Properties:
        model: (Union[str, django.db.models.Model]): Django Model or "<app_label>.<model_name>"
        fields: List[str]: List of model fields to include in the DjangoObjectType
        filter_fields: Union[Dict[str, List[str]], List[str]]: filter_fields configuration as normally used with django_filter
        filterset_class: FilterSet: An optional fielterset_class instead
        type_props: Dict[str, Any]: additional properties to be merged with DjangoObjectType for overwrites
        meta_props: Dict[str, Any]: additional properties to be merged with object type Meta for overwrites
        query_route_name: str | None: the root field name for the single record query
        query_route_name_plural: str | None: the root field name for the list of records
        query_operations: Literal["list", "detail"]: list of permitted read operations
        mutation_operations: Literal["create", "update", "delete"]: list of mutation operations
        object_type_name: str | None: if provided will be used instead of autogenerated conventional name

    Args:
        TypedDict (_type_): Dictionary of Kwargs for NodeType Meta class
    """
    model: Union[str, models.Model]
    fields: List[str] | Literal["__all__"]
    query_route_name: str | None
    query_route_name_plural: str | None
    filter_fields: Union[Dict[str, List[str]], List[str]]
    filterset_class: FilterSet
    query_operations: Literal["list", "detail"]
    object_type_name: str | None
    type_props: Dict[str, Any]
    meta_props: Dict[str, Any]
    mutation_operations: Literal["create", "update", "delete"]
    extra_kwargs: Dict[str, Dict[str, Any]]
    field_validators: Dict[str, List[Callable]]
    non_field_validators: List[Callable]
    success_keyword: str
    input_field_name: str
    return_field_name: str
    get_queryset: Callable
    permissions: List[str]
    permission_classes: List


DEFAULT_META_KWARGS: MetaKwargs = {
    'model':  None,
    'fields': [],
    'query_route_name': None,
    'query_route_name_plural':  None,
    'filter_fields': {},
    'filterset_class': None,
    'query_operations': ["list", "detail"],
    'mutation_operations': ["create", "update", "delete"],
    'object_type_name': None,
    'type_props': {},
    'meta_props': {},
    'extra_kwargs': {},
    'success_keyword': None,
    'field_validators': {},
    'non_field_validators': [],
    'input_field_name': None,
    'return_field_name': None,
    "permissions": [],
    "permission_classes": []
}


class NodeType:
    model: type[models.Model]
    conventional_name: str
    django_object_type: type[DjangoObjectType]
    input_object_type: graphene.InputObjectType
    django_abstract_mutation_type: type[DjangoClientIDMutation]

    def __init_subclass__(cls, **kwargs) -> None:

        if cls is not NodeType and not issubclass(cls, NodeType):
            raise AssertionError(
                "NodeType is intended to be used as base class for creating subclasses! ")
        if not cls.Meta.model:
            raise AssertionError(
                f"Django model or '<app_label.model_name> should be provided on {cls.__name__}.Meta.model'")
        if not cls.Meta.fields:
            raise AssertionError(
                f"You must explicitly provide the list of fields (List[str]) or Literal['__all__']")
        for key, default in DEFAULT_META_KWARGS.items():
            if not getattr(cls.Meta, key, None):
                setattr(cls.Meta, key, default)
        assert_permissions_are_valid(cls.Meta.permissions)
        assert_permission_classes_are_valid(cls.Meta.permission_classes)

    def __init__(self) -> None:
        self.__prepare_model_class__()
        self.__configure_conventional_name__()
        if self.Meta.fields == '__all__':
            fields = [field.name for field in self.model._meta.get_fields()]
        else:
            fields = self.Meta.fields
        
        self.fields = fields

        self.django_object_type = configure_node_object_type(
            model=self.model,
            conventional_name=self.conventional_name,
            fields=fields,
            filter_fields=self.Meta.filter_fields,
            filterset_class=self.Meta.filterset_class,
            custom_get_queryset=self.__class__.get_queryset if hasattr(self.__class__, 'get_queryset') else None,
            permissions=self.Meta.permissions,
            permission_classes=self.Meta.permission_classes,
        )
        self.django_abstract_mutation_type = configure_abstract_mutation(
            django_object_type=self.django_object_type,
            conventional_name=self.conventional_name,
            permissions=self.Meta.permissions,
            permission_classes=self.Meta.permission_classes
        )

        self.input_object_type = configure_input_object_type(
            abstract_mutation_type=self.django_abstract_mutation_type, 
            fields=fields, 
            extra_kwargs=self.Meta.extra_kwargs,
        )

        

    def __prepare_model_class__(self) -> None:
        if isinstance(self.Meta.model, str):
            description = self.Meta.model.split('.')
            django_model = apps.get_model(description[0], description[1])
        else:
            django_model = self.Meta.model
        self.model = django_model

    def __configure_conventional_name__(self) -> str:
        """Returns a conventional name for object type made form django model's app_label and model_name

        Returns:
            str: a name made form django model's app_label and model_name
        """
        if hasattr(self.Meta, "object_type_name") and self.Meta.object_type_name:
            self.conventional_name = self.Meta.object_type_name
        else:
            self.conventional_name = f'{self.model._meta.app_label.capitalize()}{self.model._meta.model_name.capitalize()}'

    def configure_queries(self) -> graphene.ObjectType:
        """Configures the graphene query object types for single and multiple records.

        Returns:
            graphene.ObjectType: The configured grpahene query ObjectType
        """
        return configure_queries(
            django_object_type=self.django_object_type,
            conventional_name=self.conventional_name,
            query_field_name=self.Meta.query_route_name,
            query_field_name_plural=self.Meta.query_route_name_plural,
            query_operations=self.Meta.query_operations
        )

    def configure_mutations(self) -> type[graphene.ObjectType]:
        """
        Configures mutations with "create_<model._meta.model_name>", "update_<model._meta.model_name>", "delete_<model._meta.model_name>" root fields per Meta.mutation_operations.

        Returns:
            type[graphene.ObjectType]: A configured extended graphene.ObjectType with mutation root fields
        """
        root = {}

        if "create" in self.Meta.mutation_operations:
            create_mutation = configure_create_mutation(
                input_object_type=self.input_object_type,
                abstract_mutation_type=self.django_abstract_mutation_type,
                conventional_name=self.conventional_name,
                input_field_name=self.Meta.input_field_name,
                return_field_name=self.Meta.return_field_name,
            )
            root[f"create_{self.model._meta.model_name}"] = create_mutation.Field()

        if "update" in self.Meta.mutation_operations:
            update_mutation = configure_update_mutation(
                input_object_type=self.input_object_type,
                abstract_mutation_type=self.django_abstract_mutation_type,
                conventional_name=self.conventional_name,
                input_field_name=self.Meta.input_field_name,
                return_field_name=self.Meta.return_field_name,
            )
            root[f"update_{self.model._meta.model_name}"] = update_mutation.Field()

        if "delete" in self.Meta.mutation_operations:
            delete_mutation = configure_delete_mutation(
                abstract_mutation_type=self.django_abstract_mutation_type,
                conventional_name=self.conventional_name,
                )
            root[f"delete_{self.model._meta.model_name}"] = delete_mutation.Field()

        return type(f'{self.conventional_name}Mutation', (graphene.ObjectType, ), root)
